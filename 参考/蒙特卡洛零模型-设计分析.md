# 蒙特卡洛零模型 (Monte of Zero Model) — 设计可行性分析

> 《零之王牌》核心问题：**硬核德扑 vs 爽文叙事** 的不兼容性解法

---

## 一、问题本质

### 1.1 矛盾根源

| 维度 | 硬核德扑 | 爽文叙事 |
|------|----------|----------|
| 节奏 | 大量弃牌、等待、磨耗 | 每一手都要有戏剧张力 |
| 结果 | 随机、反直觉、冷酷 | 主角需要逆转、高潮、燃点 |
| 控制感 | 玩家对结果控制力极低 | 玩家需要感受到"我的选择改变了命运" |
| AI叙事 | 无法从"2♠7♦ vs A♠K♠"中编出好故事 | 需要每局都有叙事价值 |

### 1.2 两条路线对比

| | 演出型 (Interactive Cinema) | 机制型 (Rigged Poker) |
|---|---|---|
| **核心思路** | AI LLM 预编排剧本，玩家选选项微调 | 表面是德扑，底层是"老千扑克"，改变RNG |
| **玩家体验** | 互动电影，选择感弱 | 真正在"打牌"，但命运可操控 |
| **设计难度** | 中等（本质是分支叙事） | 极高（需要抽象德扑底层概率） |
| **重玩性** | 低（剧本固定） | 高（每局不同） |
| **AI LOG质量** | 高（剧本预设，叙事完整） | 高（牌局真实发生，但结果被引导向戏剧性） |
| **致命缺陷** | 不是游戏，是PPT | 副作用极难控制——"帮Rino结果喂饱了Kazu" |

**结论：机制型是正确方向，但需要解决"副作用"这个核心难题。**

---

## 二、蒙特卡洛零模型——核心解法

### 2.1 哲学转换

> **不要改牌，改胜率。**
> 
> 每一张未翻开的牌 = 无数个平行宇宙的叠加态。
> 技能不是"变魔术变出牌"，而是"对平行宇宙进行筛选"。

- **Rino 的魔运** → 从所有可能的未来中，挑选对自己最有利的那个
- **Kazu 的空白因子** → 把被锁定的未来打碎，回归纯随机

这完美映射了世界观设定：
- Rino 是"命运操控者"，不是"变牌者"
- Kazu 是"命运干涉链之外的空白"，不是"反魔法者"

### 2.2 算法流程

```
传统发牌:  Random(Deck) → 发一张牌
零模型发牌: Generate(N futures) → Evaluate(All) → Filter(by skill) → Pick(1)
```

#### 步骤详解：

```
┌─────────────────────────────────────────────────┐
│  触发条件: 发公共牌时 (Flop/Turn/River)          │
│  注意: 底牌(Hole Cards)永远纯随机发放             │
└──────────────────────┬──────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────┐
│  STEP 1: 生成平行宇宙 (Generate Futures)         │
│                                                   │
│  从剩余牌堆中，枚举/采样 N 张候选牌              │
│  N = 剩余牌数 (通常 44~47张，完全可以全遍历)     │
└──────────────────────┬──────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────┐
│  STEP 2: 评估每个宇宙 (Evaluate Reality)         │
│                                                   │
│  对每张候选牌，用 pokersolver 计算:               │
│  - 将候选牌加入当前公共牌                         │
│  - 计算所有玩家的最终牌型                         │
│  - 判定: 谁赢？赢多少？                          │
│                                                   │
│  输出: candidateCard → { rinoWin, kazuWin,        │
│         winnerDelta, handStrength... }            │
└──────────────────────┬──────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────┐
│  STEP 3: 技能过滤 (Skill as Filter)              │
│                                                   │
│  无技能激活 → Random(All candidates)              │
│  Rino魔运激活 → Filter(rinoWin > kazuWin)        │
│                  → Pick(delta最大的)              │
│  Kazu空白因子 → 强制回退到 Random(All)            │
│  双方技能冲突 → 见冲突解决机制                    │
└──────────────────────┬──────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────┐
│  STEP 4: 发牌 (Deal the chosen card)             │
│                                                   │
│  从牌堆中移除选中的牌，正常发出                   │
│  对AI LOG: 只输出"发了什么牌"，不暴露筛选过程     │
└─────────────────────────────────────────────────┘
```

### 2.3 与现有代码的兼容性分析

#### pokersolver — ✅ 完全可用，无需修改

`pokersolver.js` 提供了完整的牌型评估能力：

```javascript
// 现有API完全满足需求
Hand.solve(['Ad', '3c', 'Th', '7s', '2d'])  // → 评估牌型
Hand.winners([hand1, hand2])                  // → 判定赢家
hand.compare(otherHand)                       // → 比较大小
```

评估每个"平行宇宙"只需要：
```javascript
function evaluateUniverse(candidateCard, board, players) {
  const futureBoard = [...board, candidateCard];
  const boardStr = futureBoard.map(cardToSolverString);
  
  const hands = players.map(p => {
    const cards = [...p.cards.map(cardToSolverString), ...boardStr];
    return { player: p, hand: Hand.solve(cards) };
  });
  
  const winners = Hand.winners(hands.map(h => h.hand));
  // 返回每个玩家的胜负状态
}
```

**pokersolver 的 `Hand.solve` 和 `Hand.winners` 就是现成的"宇宙评估器"。**

#### texas-holdem.js — 需要修改发牌逻辑

当前发牌是纯随机的（`deckLib.cards.pop()`）：

```javascript
// 当前: distributeCommunityCard() 直接 pop
const card = deckLib.cards.pop();  // 纯随机
gameState.board.push(card);
```

需要改为：
```javascript
// 改造后: 先筛选，再从牌堆中精确抽取
const chosenCard = monteOfZero.selectCard(deckLib.cards, gameState, activeSkills);
removeCardFromDeck(deckLib.cards, chosenCard);  // 从牌堆中移除指定牌
gameState.board.push(chosenCard);
```

**关键改动点只有3处：`dealFlop`、`dealTurn`、`dealRiver` 中的发牌调用。**

#### deck-of-cards 库 — 需要小幅适配

`deck-of-cards` 库的 `cards.pop()` 是从数组末尾取牌。要实现"指定发某张牌"，需要：

1. 从 `deckLib.cards` 数组中找到目标牌
2. 将其移到数组末尾（或直接 splice 移除）
3. 然后正常调用动画

```javascript
function pickSpecificCard(deck, targetCard) {
  const index = deck.cards.findIndex(c => 
    c.rank === targetCard.rank && c.suit === targetCard.suit
  );
  if (index === -1) return deck.cards.pop(); // fallback
  
  // 将目标牌移到末尾，然后 pop
  const [card] = deck.cards.splice(index, 1);
  deck.cards.push(card);  // 放到末尾
  return deck.cards.pop(); // pop 出来
}
```

**这是唯一需要"hack"库的地方，而且非常简单。**

---

## 三、技能系统设计

### 3.1 技能定义

| 技能 | 持有者 | 效果 | 世界观映射 |
|------|--------|------|-----------|
| **魔运·大吉** | Rino | 从所有候选牌中，选择使 Rino 胜率最高的牌 | 幸运型魔运：提升赌局优势概率 |
| **魔运·先知** | Rino | 预览下一张牌的3个候选（玩家可看到） | 感知型魔运：感知赌局走势 |
| **魔运·厄运** | 对手AI | 从候选牌中，选择使目标玩家胜率最低的牌 | 对手的魔运干涉 |
| **空白因子** | Kazu | 使本次发牌强制回归纯随机，无视所有魔运筛选 | 命运干涉链外的空白 |
| **魔运反噬** | 系统 | Rino 连续使用魔运后，下N张牌自动选择对 Rino 最不利的 | 魔运副作用 |

### 3.2 筛选逻辑伪代码

```javascript
function monteOfZeroSelect(remainingCards, board, players, activeSkills) {
  // STEP 1: 生成所有候选宇宙
  const universes = remainingCards.map(card => {
    const futureBoard = [...board.map(cardToSolverString), cardToSolverString(card)];
    
    const results = {};
    players.forEach(p => {
      if (p.folded) return;
      const fullHand = [...p.cards.map(cardToSolverString), ...futureBoard];
      results[p.id] = Hand.solve(fullHand);
    });
    
    const allHands = Object.values(results);
    const winners = Hand.winners(allHands);
    
    return {
      card: card,
      results: results,
      winners: winners,
      // 计算每个玩家的"胜率分数"
      scores: calculateScores(results, winners, players)
    };
  });
  
  // STEP 2: 应用技能过滤器
  if (activeSkills.includes('KAZU_BLANK_FACTOR')) {
    // 空白因子: 强制纯随机，无视一切
    return randomPick(universes).card;
  }
  
  if (activeSkills.includes('RINO_FORTUNE_MAJOR')) {
    // 魔运·大吉: 选择 Rino 胜率最高的宇宙
    const rinoFavorable = universes
      .filter(u => u.scores.rino > u.scores.opponent)  // Rino赢的宇宙
      .sort((a, b) => b.scores.rino - a.scores.rino);  // 按优势排序
    
    if (rinoFavorable.length > 0) {
      return rinoFavorable[0].card;  // 最有利的那张
    }
    // 如果没有任何宇宙 Rino 能赢，魔运失败，回退随机
    return randomPick(universes).card;
  }
  
  if (activeSkills.includes('BACKLASH')) {
    // 魔运反噬: 选择对 Rino 最不利的
    const rinoWorst = universes
      .sort((a, b) => a.scores.rino - b.scores.rino);
    return rinoWorst[0].card;
  }
  
  // 无技能: 纯随机
  return randomPick(universes).card;
}
```

### 3.3 多人桌的处理

这是你提到的"公池难题"——Rino 想赢，但公共牌影响所有人。

**蒙特卡洛零模型天然解决了这个问题：**

```javascript
// 评估函数不是看"发什么牌"，而是看"谁赢了"
function calculateScores(results, winners, players) {
  const rinoHand = results[RINO_ID];
  const scores = { rino: 0, opponent: 0 };
  
  // Rino 是否在赢家中？
  if (winners.includes(rinoHand)) {
    scores.rino = 100;
    scores.opponent = 0;
  } else {
    scores.rino = 0;
    scores.opponent = 100;
  }
  
  // 更精细: 用 hand.rank 和 compare 计算相对优势
  // 这样即使 Rino 不是赢家，也能选择"输得最少"的宇宙
  
  return scores;
}
```

**关键洞察：过滤的是"结果"（谁赢），不是"过程"（发什么牌）。**

所以即使公共牌同时帮了 Rino 和某个 AI 对手，只要最终结果是 Rino 赢，这个宇宙就是合格的。这完美避开了"帮 Rino 结果把对手喂饱"的副作用。

### 3.4 技能冲突解决 (Conflict Resolution)

当多个技能同时激活时的优先级：

```
优先级（从高到低）:
1. Kazu 空白因子 (绝对优先 — 命运干涉链之外)
2. 魔运反噬 (系统级惩罚)
3. 对手魔运·厄运
4. Rino 魔运·大吉
5. 无技能 (纯随机)
```

**冲突场景示例：**

| 场景 | Rino 技能 | 对手技能 | Kazu 技能 | 结果 |
|------|-----------|----------|-----------|------|
| A | 大吉 | 无 | 无 | Rino 最优牌 |
| B | 大吉 | 厄运 | 无 | 双方筛选冲突 → 折中随机（从中间段选） |
| C | 大吉 | 厄运 | 空白因子 | **纯随机** — Kazu 打碎一切 |
| D | 反噬中 | 无 | 无 | Rino 最差牌 |
| E | 反噬中 | 无 | 空白因子 | **纯随机** — Kazu 连反噬都能抵消 |

场景 E 特别有叙事价值：Rino 陷入反噬，本该厄运缠身，但 Kazu 的存在让命运回归混沌——这就是"空白因子"的战略价值。

---

## 四、性能分析

### 4.1 计算量评估

| 阶段 | 剩余牌数 | 需要评估的宇宙数 | pokersolver 调用次数 | 预估耗时 |
|------|----------|------------------|---------------------|----------|
| Flop (3张) | 52 - 2×N人 | 最多 ~44张 × 3轮 | ~44 × 玩家数 × 3 | < 50ms |
| Turn (1张) | ~41 | ~41 | ~41 × 玩家数 | < 20ms |
| River (1张) | ~40 | ~40 | ~40 × 玩家数 | < 20ms |

**结论：完全可以全遍历，不需要采样。** 

`pokersolver.js` 的 `Hand.solve()` 是纯 CPU 计算，单次调用 < 0.1ms。即使 6 人桌全遍历所有候选牌，总计算量也在 **100ms 以内**，对用户完全无感。

### 4.2 Flop 的特殊处理

Flop 一次发 3 张牌，候选空间是 C(44,3) ≈ 13,244 种组合。这仍然可以全遍历（13,244 × 6人 ≈ 80,000 次 Hand.solve，约 800ms），但如果觉得慢，可以：

**方案A：逐张筛选（推荐）**
```
Flop第1张 → 蒙特卡洛筛选 → 选出最优
Flop第2张 → 基于第1张结果，再筛选 → 选出最优
Flop第3张 → 基于前2张结果，再筛选 → 选出最优
```
每次只遍历 ~44 张，3次 = ~132 次评估，极快。

**方案B：采样筛选**
从 13,244 种组合中随机采样 200 种，评估后选最优。

**推荐方案A**，因为逐张筛选更符合"命运逐步展开"的叙事感。

---

## 五、对 AI LOG 的影响

### 5.1 LOG 输出原则

**对 AI LLM 的 LOG 永远只输出标准德扑信息：**

```
[BOARD] Flop dealt: Kh 7d 2c
[BOARD] Turn dealt: As (Board: Kh 7d 2c As)
[BOARD] River dealt: Qh (Board: Kh 7d 2c As Qh)
```

**绝不暴露筛选过程。** AI LLM 看到的就是一局正常的德扑，它不知道这张牌是被"命运"选中的。

### 5.2 叙事元数据（可选，供高级 AI 使用）

可以在 LOG 中附加一个隐藏的元数据层：

```json
{
  "type": "BOARD",
  "card": "As",
  "meta": {
    "skillUsed": "RINO_FORTUNE_MAJOR",
    "alternativeCards": ["3d", "7c", "Jh"],
    "rinoWinRateBeforeSkill": 0.23,
    "rinoWinRateAfterSkill": 0.78,
    "dramaticShift": true
  }
}
```

这样 AI LLM 可以根据 `dramaticShift: true` 来生成"命运转折"的叙事，而不需要理解扑克数学。

---

## 六、叙事戏剧性保障

### 6.1 问题：技能让每局都赢，反而没有张力

如果 Rino 每次都用魔运选最优牌，那就是"稳赢模拟器"，同样没有叙事价值。

**解法：魔运资源系统 + 反噬机制**

```
魔运储备: 100 (初始)

使用大吉: -30 储备
使用先知: -15 储备
自然恢复: +5/轮

储备 < 20: 进入"虚弱"状态，技能效果减半
储备 = 0:  触发"魔运反噬"，接下来3张牌自动选最差
储备 < 0:  "深度反噬"，Rino 的手牌也会被影响（发到差牌）
```

这创造了核心决策张力：
- **什么时候用魔运？** 太早用完会反噬，太晚用可能已经输了
- **Kazu 什么时候用空白因子？** 在 Rino 反噬时用 = 救命；在 Rino 大吉时用 = 拆台
- **资源管理** 本身就是一个有深度的策略层

### 6.2 戏剧性发牌模式（可选增强）

除了技能筛选，还可以加入"戏剧性偏好"：

```javascript
function addDramaticBias(universes, phase) {
  if (phase === 'river') {
    // 河牌倾向于选择"逆转"或"确认"的牌
    // 即: 让领先者更领先，或让落后者翻盘
    // 避免选择"无聊"的牌（对局势没有影响的）
    return universes.filter(u => 
      Math.abs(u.scores.rino - u.scores.opponent) > 30  // 要么大赢要么大输
    );
  }
  return universes;
}
```

这不是作弊，而是"命运本身倾向于戏剧性"——完美符合魔运世界观。

---

## 七、实现路线图

### Phase 1: 基础引擎（最小可行版本）

**改动文件：`texas-holdem.js`**

1. 新增 `MonteOfZero` 类（或独立文件 `monte-of-zero.js`）
2. 修改 `distributeCommunityCard()` — 在发牌前调用筛选
3. 新增 `pickSpecificCard()` — 从牌堆中精确抽取指定牌

**不改动：`pokersolver.js`、`poker-ai.js`、`deck-of-cards/`**

预估工作量：**1-2天**

### Phase 2: 技能系统

1. 新增技能定义和资源管理
2. UI 上添加技能按钮（Rino 的魔运 / Kazu 的空白因子）
3. 技能冲突解决逻辑

预估工作量：**2-3天**

### Phase 3: AI LOG 集成

1. 扩展日志系统，添加元数据层
2. 生成供 AI LLM 使用的结构化叙事数据

预估工作量：**1天**

### Phase 4: 戏剧性增强（可选）

1. 戏剧性偏好筛选
2. 魔运反噬的视觉/叙事效果
3. 多人桌的复杂技能交互

预估工作量：**2-3天**

---

## 八、结论

### 可行吗？

**完全可行。** 理由：

1. **pokersolver 完全够用** — `Hand.solve()` + `Hand.winners()` 就是现成的宇宙评估器，零修改
2. **性能无压力** — 全遍历 40-50 张候选牌，< 100ms，用户无感
3. **代码改动极小** — 只需要在发公共牌的 3 个函数中插入筛选逻辑
4. **副作用问题被根治** — 过滤"结果"而非"过程"，天然避免"帮错人"
5. **完美映射世界观** — Rino 筛选命运，Kazu 打碎命运，不是变魔术

### 需要注意的风险

1. **Flop 三张牌的关联性** — 逐张筛选可能导致"第1张最优但第2、3张变差"，需要测试
2. **多人桌平衡** — 当 Rino 对抗 5 个 AI 时，"Rino 赢"的宇宙可能很少，技能效果会自然减弱（这其实是好事——符合"以少敌多"的叙事）
3. **玩家感知** — 需要确保玩家能"感受到"技能生效了（视觉反馈、音效、AI叙事配合）

### 最终判断

**蒙特卡洛零模型是目前能想到的最优解。** 它在不破坏德扑规则完整性的前提下，用概率筛选替代了牌面操控，从根本上解决了"硬核德扑 vs 爽文叙事"的矛盾。

核心哲学一句话总结：

> **Rino 不是在变牌，她是在挑选对自己最有利的未来；Kazu 不是在变牌，他是在把被选定的未来打碎回随机。**
